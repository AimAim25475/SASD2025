# C# Class จาก .Net Based APIs

## บทนำ
เอกสารนี้นำเสนอตัวอย่าง C# Class จากระบบ .NET Framework APIs ที่จัดแบ่งตามลักษณะของ Class ทั้ง 3 กลุ่ม ได้แก่ Utility Class, Mutable Class, และ Immutable Class โดยแต่ละคลาสจะได้รับการวิเคราะห์อย่างลึกซึ้งว่าเพราะเหตุใดจึงอยู่ในกลุ่มดังกล่าว

---

## a) Utility Class - `System.Math`

### คำนิยาม
**Utility Class** คือ คลาสที่ออกแบบมาเพื่อให้บริการเป็นเครื่องมือช่วยในการทำงานต่างๆ โดยจะมีเฉพาะ Static Methods และ Static Fields เท่านั้น ไม่มีการเก็บสถานะ (State) หรือข้อมูลของ Instance ตัวมันเอง

### ตัวอย่าง: `System.Math`

```csharp
// คำนิยามจาก .NET API
public static class Math
{
    // Static Fields
    public static readonly double PI = 3.14159...;
    public static readonly double E = 2.71828...;
    
    // Static Methods สำหรับการคำนวณทางคณิตศาสตร์
    public static double Abs(double value);
    public static double Sqrt(double value);
    public static double Pow(double x, double y);
    public static double Sin(double angle);
    public static double Cos(double angle);
    public static double Tan(double angle);
    public static int Max(int a, int b);
    public static int Min(int a, int b);
    // ... และอีกมาก
}

// ตัวอย่างการใช้งาน
double result1 = Math.Abs(-5.5);           // ผลลัพธ์: 5.5
double result2 = Math.Sqrt(16);             // ผลลัพธ์: 4.0
double result3 = Math.Pow(2, 3);            // ผลลัพธ์: 8.0
int maxValue = Math.Max(10, 20);            // ผลลัพธ์: 20
double pi = Math.PI;                        // ได้ค่า PI = 3.14159...
```

### วิเคราะห์ว่าเพราะเหตุใด `Math` จึงเป็น Utility Class

1. **ไม่สามารถสร้าง Instance ได้**
   - `Math` ถูกประกาศเป็น `static class` จึงไม่สามารถสร้าง Object ขึ้นได้
   - ไม่มีการเก็บข้อมูลส่วนตัว (Instance Variables)

2. **มีเฉพาะ Static Methods และ Fields**
   - วิธีการทั้งหมดเป็น `public static` 
   - สามารถเรียกใช้ได้โดยตรงผ่านชื่อคลาส เช่น `Math.Sqrt()`, `Math.Max()`

3. **ไม่มีสถานะ (Stateless)**
   - ผลการทำงานของ Method ขึ้นอยู่กับ Input Parameter เท่านั้น
   - ไม่มีการเปลี่ยนแปลง Instance State เพราะไม่มี Instance

4. **วัตถุประสงค์: เป็นเครื่องมือช่วยเหลือ**
   - ให้บริการฟังก์ชันทางคณิตศาสตร์และตรีโกณมิติ
   - เป็นตัวช่วยในการคำนวณสำหรับ Operations ต่างๆ

---

## b) Mutable Class - `System.Text.StringBuilder`

### คำนิยาม
**Mutable Class** คือ คลาสที่ออกแบบมาเพื่อให้สามารถเปลี่ยนแปลงสถานะ (State) ของ Object หลังจากสร้างขึ้นได้ Mutable Class มักจะมี Properties ที่สามารถ Set หรือ Methods ที่เปลี่ยนข้อมูลภายในวัตถุ

### ตัวอย่าง: `System.Text.StringBuilder`

```csharp
// คำนิยามจาก .NET API
public sealed class StringBuilder : System.Runtime.Serialization.ISerializable
{
    // Constructors
    public StringBuilder();
    public StringBuilder(string? value);
    public StringBuilder(int capacity);
    public StringBuilder(string? value, int capacity);
    
    // Properties ที่สามารถ Modify ได้
    public int Length { get; set; }                    // สามารถเปลี่ยนความยาว
    public int Capacity { get; set; }                  // สามารถเปลี่ยน Capacity
    public char this[int index] { get; set; }          // สามารถเปลี่ยนอักขระแต่ละตัว
    
    // Methods ที่ Modify Object
    public StringBuilder Append(string? value);         // เพิ่มข้อความ
    public StringBuilder Insert(int index, string? value); // แทรกข้อความ
    public StringBuilder Remove(int startIndex, int length); // ลบข้อความ
    public StringBuilder Replace(string oldValue, string newValue); // แทนที่ข้อความ
    public StringBuilder Clear();                      // ลบทั้งหมด
    public string ToString();                          // คืนค่า String
}

// ตัวอย่างการใช้งาน
StringBuilder sb = new StringBuilder("Hello");
Console.WriteLine(sb);                                  // ผลลัพธ์: Hello

sb.Append(" World");                                   // เปลี่ยนแปลง sb
Console.WriteLine(sb);                                  // ผลลัพธ์: Hello World

sb.Insert(5, ",");                                     // แทรก "," ที่ตำแหน่ง 5
Console.WriteLine(sb);                                  // ผลลัพธ์: Hello, World

sb[0] = 'h';                                           // เปลี่ยนอักขระแรก
Console.WriteLine(sb);                                  // ผลลัพธ์: hello, World

sb.Replace("World", "Universe");                       // แทนที่ "World" ด้วย "Universe"
Console.WriteLine(sb);                                  // ผลลัพธ์: hello, Universe

sb.Clear();                                            // ลบทั้งหมด
Console.WriteLine(sb.Length);                          // ผลลัพธ์: 0
```

### วิเคราะห์ว่าเพราะเหตุใด `StringBuilder` จึงเป็น Mutable Class

1. **สามารถเปลี่ยนแปลงสถานะ (State)**
   - ผ่าน Methods เช่น `Append()`, `Insert()`, `Remove()`, `Replace()`, `Clear()`
   - ผ่าน Properties เช่น `Length`, `Capacity`
   - สามารถเปลี่ยนแปลงอักขระโดยใช้ Indexer `sb[index] = newChar`

2. **Methods ส่วนใหญ่เปลี่ยนแปลง Object เดิม**
   ```csharp
   StringBuilder sb = new StringBuilder("ABC");
   sb.Append("DEF");  // เปลี่ยนแปลง sb เป็น "ABCDEF"
   // ไม่สร้าง StringBuilder ใหม่ เพียงแค่แก้ไข sb ที่มีอยู่
   ```

3. **ประสิทธิภาพในวลูป**
   - เหมาะสำหรับการสร้างสตริงขนาดใหญ่พื้นๆหลายครั้ง
   - เพราะว่าแก้ไข String เดิมโดยไม่สร้าง String Object ใหม่ตลอดเวลา
   ```csharp
   // ไม่ดี: สร้าง String ใหม่เสมอ
   string result = "";
   for (int i = 0; i < 1000; i++)
   {
       result += i.ToString();  // สร้าง String ใหม่ 1000 ครั้ง (ใช้ทรัพยากรมาก)
   }
   
   // ดี: ใช้ StringBuilder
   StringBuilder sb = new StringBuilder();
   for (int i = 0; i < 1000; i++)
   {
       sb.Append(i.ToString());  // แก้ไข StringBuilder เดิม
   }
   string result = sb.ToString();
   ```

4. **คลาสเป็น Reference Type**
   - การแก้ไข StringBuilder จะส่งผลต่อ Object เดิม ไม่ใช่สำเนา

---

## c) Immutable Class - `System.String`

### คำนิยาม
**Immutable Class** คือ คลาสที่ไม่สามารถเปลี่ยนแปลงสถานะ (State) ของ Object หลังจากสร้างขึ้นได้ วิธีการทั้งหมดจะคืนค่า Object ใหม่ แทนที่จะเปลี่ยนแปลง Object เดิม

### ตัวอย่าง: `System.String`

```csharp
// คำนิยามจาก .NET API
public sealed class String : 
    ICloneable, IComparable, IComparable<string>, 
    IConvertible, IEquatable<string>, IEnumerable<char>
{
    // Constructor
    public String(char[] value);
    public String(char c, int count);
    
    // Read-Only Property
    public int Length { get; }  // สามารถอ่านได้เท่านั้น ไม่สามารถ Set ได้
    
    // Methods ที่คืนค่า String ใหม่ (ไม่เปลี่ยนแปลง String เดิม)
    public string Substring(int startIndex, int length);
    public string ToUpper();
    public string ToLower();
    public string Trim();
    public string Replace(string oldValue, string newValue);
    public string[] Split(char[] separator);
    public string Insert(int startIndex, string value);
    public string Remove(int startIndex, int count);
    public string Concat(strings first, string second);
    // ... และอีกมาก
}

// ตัวอย่างการใช้งาน
string str1 = "Hello";
string str2 = str1.ToUpper();  // str2 = "HELLO"
Console.WriteLine(str1);       // ผลลัพธ์: Hello (ไม่เปลี่ยน)

string str3 = "Hello World";
string str4 = str3.Replace("World", "Universe");  // str4 = "Hello Universe"
Console.WriteLine(str3);       // ผลลัพธ์: Hello World (ไม่เปลี่ยน)

string str5 = "Hello";
string str6 = str5 + " World"; // สร้าง String Object ใหม่
Console.WriteLine(str5);       // ผลลัพธ์: Hello (ไม่เปลี่ยน)
```

### วิเคราะห์ว่าเพราะเหตุใด `String` จึงเป็น Immutable Class

1. **ไม่สามารถเปลี่ยนแปลงหลังจากสร้างขึ้น**
   - ไม่มี Setter สำหรับ Properties
   - ไม่สามารถเปลี่ยนแปลงอักขระแต่ละตัวได้
   ```csharp
   string str = "Hello";
   // str[0] = 'J';  // ❌ ข้อผิดพลาด: Property or indexer 'string.this[int]' cannot be assigned to
   ```

2. **วิธีการทั้งหมดคืนค่า String ใหม่**
   - วิธีการไม่เปลี่ยนแปลง String เดิม เพียงแค่สร้าง String ใหม่ให้เราเลือก
   ```csharp
   string original = "Hello";
   
   // ToUpper() คืนค่า String ใหม่ ไม่เปลี่ยน original
   string uppercase = original.ToUpper();  // uppercase = "HELLO"
   Console.WriteLine(original);             // ยังคงเป็น "Hello"
   
   // Replace() ก็เช่นกัน
   string replaced = original.Replace("H", "J");  // replaced = "Jello"
   Console.WriteLine(original);                    // ยังคงเป็น "Hello"
   ```

3. **Thread-Safe และปลอดภัยมากกว่า**
   - เนื่องจากไม่สามารถเปลี่ยนแปลง String ได้หลังจากสร้างขึ้น
   - หลาย Threads สามารถใช้ String เดียวกันได้พร้อมกันโดยปลอดภัย
   ```csharp
   string sharedString = "Configuration Data";
   
   // Thread 1, 2, 3... สามารถอ่าน sharedString พร้อมกันได้
   // โดยไม่ต้องกังวลเรื่องการเปลี่ยนแปลง
   string thread1Result = sharedString.ToUpper();
   string thread2Result = sharedString.Substring(0, 5);
   ```

4. **Performance Optimization**
   - .NET สามารถ Cache String Literals ได้
   - หลาย Reference อาจชี้ไปยัง String Object เดียวกัน (String Interning)
   ```csharp
   string str1 = "Hello";
   string str2 = "Hello";
   
   // str1 และ str2 อาจชี้ไปยัง Object เดียวกันได้
   // เพราะว่า String ไม่สามารถเปลี่ยนแปลง
   ```

5. **Sealed Class ที่ไม่สามารถ Override ได้**
   - ใช้คำว่า `sealed` เพื่อป้องกันการสืบทอดและการเปลี่ยนแปลงพฤติกรรม

---

## สรุปการเปรียบเทียบ

| คุณลักษณะ | Utility (Math) | Mutable (StringBuilder) | Immutable (String) |
|---------|---|---|---|
| **ประเภท** | static class | sealed class | sealed class |
| **สร้าง Instance** | ❌ ไม่ได้ | ✅ ได้ | ✅ ได้ |
| **เปลี่ยนแปลงสถานะ** | ❌ ไม่มี State | ✅ สามารถเปลี่ยน | ❌ ไม่สามารถเปลี่ยน |
| **Methods** | Static Methods | Instance Methods | Instance Methods |
| **ผลลัพธ์ Methods** | ผลลัพธ์ใหม่ | เปลี่ยน Object เดิม | Object ใหม่ |
| **Thread-Safe** | ✅ ค่อนข้างปลอดภัย | ❌ หากไม่ Synchronize | ✅ ปลอดภัย |
| **ประโยชน์** | เครื่องมือช่วยเหลือ | ประสิทธิภาพ การสร้าง String | ความปลอดภัย Cache |
| **ตัวอย่างการใช้** | `Math.Sqrt(16)` | `sb.Append()` | `str.ToUpper()` |

---

## บทสรุป

1. **Utility Class** (`Math`)
   - ออกแบบเพื่อให้บริการเป็นเครื่องมือ
   - ไม่มี Instance State
   - ใช้ Static Methods แต่ะเดียว

2. **Mutable Class** (`StringBuilder`)
   - ออกแบบให้สามารถเปลี่ยนแปลงข้อมูลได้
   - ประสิทธิภาพในการสร้าง String ขนาดใหญ่
   - Methods เปลี่ยนแปลง Object เดิม

3. **Immutable Class** (`String`)
   - ออกแบบให้ไม่สามารถเปลี่ยนแปลงได้
   - ปลอดภัยต่อการใช้ Multi-Threading
   - วิธีการสร้าง Object ใหม่เสมอ

การเข้าใจความแตกต่างระหว่างคลาสทั้งสามประเภทนี้จะช่วยให้ทำการออกแบบ Class โดยมีจุดประสงค์ที่ชัดเจนและเหมาะสมสำหรับแต่ละสถานการณ์
