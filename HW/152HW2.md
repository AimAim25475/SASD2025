## Code smell กลิ่นเเปลกๆ
ถ้าฟังผ่านๆ อาจจะคิดว่า code มันมีกลิ่นตุๆ code มันมีกลิ่นได้ด้วยเหรอเเต่จริงๆเเล้วมันคือคำเปรียบเทียบว่าในการเขียน code นั้นในบางส่วนที่เราเขียนมันมี error ที่อาจจะส่งผลในระยะยาว (มันไม่ใช่ bug) 

## Long Method  
function หรือเมทอดที่ยาวเพราะทำหลายอย่าง อ่านยากและทดสอบยาก ควรแยกงานเป็น function ย่อย (เช่น โหลด, ตรวจ, คำนวณ, สรุป) เพื่อความชัดเจน แต่ถ้า function ยังสั้น เข้าใจง่าย และไม่มีการซ้ำซ้อนจริง ๆ ก็ไม่จำเป็นต้องแก้

ตัวอย่าง - ก่อน Refactoring
```python
def process_order(order):
    # โหลดสินค้าจากไฟล์
    with open(order['items_file']) as f:
        items = json.load(f)
    
    # ตรวจสอบความถูกต้อง
    for item in items:
        if item['quantity'] <= 0:
            raise ValueError("Quantity must be positive")
        if item['price'] < 0:
            raise ValueError("Price cannot be negative")
    
    # คำนวณราคารวม
    total = 0
    for item in items:
        subtotal = item['price'] * item['quantity']
        tax = subtotal * 0.07
        total += subtotal + tax
    
    # ส่งอีเมลแจ้งลูกค้า
    email_body = f"Your order total is {total}"
    send_email(order['customer_email'], email_body)
    
    # บันทึกลงฐานข้อมูล
    db.orders.insert({
        'order_id': order['id'],
        'total': total,
        'timestamp': datetime.now()
    })
    
    return total
```
**ปัญหา:**
- function ยาวเกินไป ทำหลายอย่างในที่เดียว
- อ่านยาก เข้าใจยาก
- ทดสอบยาก ต้องทดสอบทุกอย่างพร้อมกัน
- แก้ไขเสี่ยง อาจกระทบส่วนอื่น
- ไม่สามารถนำแต่ละส่วนไปใช้ซ้ำได้
  
## Refactoring - หลังแยก function
```python
def load_items(path):
    """โหลดข้อมูลสินค้าจากไฟล์"""
    with open(path) as f:
        return json.load(f)

def validate_items(items):
    """ตรวจสอบความถูกต้องของข้อมูลสินค้า"""
    for item in items:
        if item['quantity'] <= 0:
            raise ValueError("Quantity must be positive")
        if item['price'] < 0:
            raise ValueError("Price cannot be negative")

def calculate_total(items):
    """คำนวณราคารวมพร้อม VAT 7%"""
    total = 0
    for item in items:
        subtotal = item['price'] * item['quantity']
        tax = subtotal * 0.07
        total += subtotal + tax
    return total

def send_order_email(customer_email, total):
    """ส่งอีเมลแจ้งยอดรวมให้ลูกค้า"""
    email_body = f"Your order total is {total}"
    send_email(customer_email, email_body)

def save_order_to_db(order_id, total):
    """บันทึกคำสั่งซื้อลงฐานข้อมูล"""
    db.orders.insert({
        'order_id': order_id,
        'total': total,
        'timestamp': datetime.now()
    })

def process_order(order):
    """ประมวลผลคำสั่งซื้อทั้งหมด"""
    items = load_items(order['items_file'])
    validate_items(items)
    total = calculate_total(items)
    send_order_email(order['customer_email'], total)
    save_order_to_db(order['id'], total)
    return total
```
**ข้อดี:**
- แต่ละ function ทำหน้าที่เดียว ชัดเจน
- อ่านเข้าใจง่าย รู้ทันทีว่าแต่ละส่วนทำอะไร
- ทดสอบง่าย สามารถทดสอบแต่ละ function แยกกันได้
- นำกลับมาใช้ใหม่ได้ (reusable)
- แก้ไขง่าย ไม่กระทบส่วนอื่น



## เมื่อไม่จำเป็นต้อง refactor  
ฟังก์ชันยังอ่านง่ายและชัดเจนแม้จะยาวหน่อย, ไม่มีการซ้ำที่ต้องดึงออกมา, มี test ครอบคลุม, เป็น script ชั่วคราว, หรือการแยกย่อยจะเพิ่มความซับซ้อน/ทำให้จัดการ state/transaction ยาก กรณีพวกนี้อาจไม่ต้อง refactor

---

## Data Class  
คลาสที่มีแต่ข้อมูล (attributes) โดยไม่มี behavior หรือ logic ที่เกี่ยวข้อง ทำให้ logic ต่าง ๆ ที่ควรอยู่ในคลาสนั้นกระจัดกระจายไปอยู่ที่อื่น ยากต่อการดูแลและแก้ไข ควรย้าย logic ที่เกี่ยวข้องกับข้อมูลเข้าไปในคลาสเพื่อความชัดเจนและง่ายต่อการบำรุงรักษา

ตัวอย่าง  
```python
# คลาสที่มีแค่ข้อมูล
class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

# logic กระจัดกระจายอยู่ข้างนอก
def calculate_total(product):
    return product.price * product.quantity

def apply_discount(product, discount_percent):
    return product.price * (1 - discount_percent / 100)

def is_in_stock(product):
    return product.quantity > 0

def get_display_name(product):
    return f"{product.name} (฿{product.price})"
```

## Refactoring  
```python
# ย้าย logic เข้าไปในคลาส
class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity
    
    def calculate_total(self):
        return self.price * self.quantity
    
    def apply_discount(self, discount_percent):
        return self.price * (1 - discount_percent / 100)
    
    def is_in_stock(self):
        return self.quantity > 0
    
    def get_display_name(self):
        return f"{self.name} (฿{self.price})"

# ใช้งาน
product = Product("Laptop", 25000, 5)
total = product.calculate_total()
discounted = product.apply_discount(10)
```

## เมื่อไม่จำเป็นต้อง refactor  
DTO (Data Transfer Object) ที่ใช้แค่ส่งข้อมูลระหว่าง layer, คลาสที่เป็น model สำหรับ database mapping, configuration object ที่มีแค่ settings, หรือ simple data structure ที่ใช้ชั่วคราว กรณีเหล่านี้มีแค่ข้อมูลก็พอ ไม่จำเป็นต้องใส่ logic
