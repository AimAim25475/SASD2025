# C# Class จาก .Net Based APIs


## a) Utility Class - `System.Math`

### คำนิยาม
**Utility Class** คือ คลาสที่ออกแบบมาเพื่อให้บริการเป็นเครื่องมือช่วยในการทำงานต่างๆ โดยจะมีเฉพาะ Static Methods และ Static Fields เท่านั้น ไม่มีการเก็บสถานะ (State) หรือข้อมูลของ Instance ตัวมันเอง

### ตัวอย่าง: `System.Math`

```csharp
// คำนิยามจาก .NET API
public static class Math
{
    // Static Fields
    public static readonly double PI = 3.14159...;
    public static readonly double E = 2.71828...;
    
    // Static Methods สำหรับการคำนวณทางคณิตศาสตร์
    public static double Abs(double value);
    public static double Sqrt(double value);
    public static double Pow(double x, double y);
    public static double Sin(double angle);
    public static double Cos(double angle);
    public static double Tan(double angle);
    public static int Max(int a, int b);
    public static int Min(int a, int b);
    // ... และอีกมาก
}

// ตัวอย่างการใช้งาน Math methods หลากหลาย
double result1 = Math.Abs(-5.5);
double result2 = Math.Sqrt(16);
double result3 = Math.Pow(2, 3);
int maxValue = Math.Max(10, 20);
double pi = Math.PI;
```

### วิเคราะห์ว่าเพราะเหตุใด `Math` จึงเป็น Utility Class

1. **ไม่สามารถสร้าง Instance ได้**
   - `Math` ถูกประกาศเป็น `static class` จึงไม่สามารถสร้าง Object ขึ้นได้
   - ไม่มีการเก็บข้อมูลส่วนตัว (Instance Variables)

2. **มีเฉพาะ Static Methods และ Fields**
   - วิธีการทั้งหมดเป็น `public static` 
   - สามารถเรียกใช้ได้โดยตรงผ่านชื่อคลาส เช่น `Math.Sqrt()`, `Math.Max()`

3. **ไม่มีสถานะ (Stateless)**
   - ผลการทำงานของ Method ขึ้นอยู่กับ Input Parameter เท่านั้น
   - ไม่มีการเปลี่ยนแปลง Instance State เพราะไม่มี Instance

4. **วัตถุประสงค์: เป็นเครื่องมือช่วยเหลือ**
   - ให้บริการฟังก์ชันทางคณิตศาสตร์และตรีโกณมิติ
   - เป็นตัวช่วยในการคำนวณสำหรับ Operations ต่างๆ

---

## b) Mutable Class - `System.Text.StringBuilder`

### คำนิยาม
**Mutable Class** คือ คลาสที่ออกแบบมาเพื่อให้สามารถเปลี่ยนแปลงสถานะ (State) ของ Object หลังจากสร้างขึ้นได้ Mutable Class มักจะมี Properties ที่สามารถ Set หรือ Methods ที่เปลี่ยนข้อมูลภายในวัตถุ

### ตัวอย่าง: `System.Text.StringBuilder`

```csharp
// คำนิยามจาก .NET API
public sealed class StringBuilder : System.Runtime.Serialization.ISerializable
{
    // Constructors
    public StringBuilder();
    public StringBuilder(string? value);
    public StringBuilder(int capacity);
    public StringBuilder(string? value, int capacity);
    
    // Properties สำหรับการแก้ไข
    public int Length { get; set; }
    public int Capacity { get; set; }
    public char this[int index] { get; set; }
    
    // Methods สำหรับการแก้ไขข้อมูล
    public StringBuilder Append(string? value);
    public StringBuilder Insert(int index, string? value);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Replace(string oldValue, string newValue);
    public StringBuilder Clear();
    public string ToString();
}

// ตัวอย่างการใช้งาน StringBuilder
StringBuilder sb = new StringBuilder("Hello");
Console.WriteLine(sb);

sb.Append(" World");
Console.WriteLine(sb);

sb.Insert(5, ",");
Console.WriteLine(sb);

sb[0] = 'h';
Console.WriteLine(sb);

sb.Replace("World", "Universe");
Console.WriteLine(sb);

sb.Clear();
Console.WriteLine(sb.Length);
```

### วิเคราะห์ว่าเพราะเหตุใด `StringBuilder` จึงเป็น Mutable Class

1. **สามารถเปลี่ยนแปลงสถานะ (State)**
   - ผ่าน Methods เช่น `Append()`, `Insert()`, `Remove()`, `Replace()`, `Clear()`
   - ผ่าน Properties เช่น `Length`, `Capacity`
   - สามารถเปลี่ยนแปลงอักขระโดยใช้ Indexer `sb[index] = newChar`

2. **Methods ส่วนใหญ่เปลี่ยนแปลง Object เดิม**
   ```csharp
   StringBuilder sb = new StringBuilder("ABC");
   sb.Append("DEF");  // เปลี่ยนแปลง sb เป็น "ABCDEF"
   // ไม่สร้าง StringBuilder ใหม่ เพียงแค่แก้ไข sb ที่มีอยู่
   ```

3. **ประสิทธิภาพในวลูป**
   - เหมาะสำหรับการสร้างสตริงขนาดใหญ่พื้นๆหลายครั้ง
   - เพราะว่าแก้ไข String เดิมโดยไม่สร้าง String Object ใหม่ตลอดเวลา
   ```csharp
   // ไม่ดี: สร้าง String ใหม่เสมอ
   string result = "";
   for (int i = 0; i < 1000; i++)
   {
       result += i.ToString();  // สร้าง String ใหม่ 1000 ครั้ง (ใช้ทรัพยากรมาก)
   }
   
   // ดี: ใช้ StringBuilder
   StringBuilder sb = new StringBuilder();
   for (int i = 0; i < 1000; i++)
   {
       sb.Append(i.ToString());  // แก้ไข StringBuilder เดิม
   }
   string result = sb.ToString();
   ```

4. **คลาสเป็น Reference Type**
   - การแก้ไข StringBuilder จะส่งผลต่อ Object เดิม ไม่ใช่สำเนา

---

## c) Immutable Class - `System.String`

### คำนิยาม
**Immutable Class** คือ คลาสที่ไม่สามารถเปลี่ยนแปลงสถานะ (State) ของ Object หลังจากสร้างขึ้นได้ วิธีการทั้งหมดจะคืนค่า Object ใหม่ แทนที่จะเปลี่ยนแปลง Object เดิม

### ตัวอย่าง: `System.String`

```csharp
// คำนิยามจาก .NET API
public sealed class String : 
    ICloneable, IComparable, IComparable<string>, 
    IConvertible, IEquatable<string>, IEnumerable<char>
{
    // Constructor
    public String(char[] value);
    public String(char c, int count);
    
    // Read-Only Property
    public int Length { get; }  // สามารถอ่านได้เท่านั้น ไม่สามารถ Set ได้
    
    // Methods ที่คืนค่า String ใหม่ (ไม่เปลี่ยนแปลง String เดิม)
    public string Substring(int startIndex, int length);
    public string ToUpper();
    public string ToLower();
    public string Trim();
    public string Replace(string oldValue, string newValue);
    public string[] Split(char[] separator);
    public string Insert(int startIndex, string value);
    public string Remove(int startIndex, int count);
    public string Concat(strings first, string second);
    // ... และอีกมาก
}

// ตัวอย่างการใช้งาน String (ผลลัพธ์มาจาก String ใหม่)
string str1 = "Hello";
string str2 = str1.ToUpper();
Console.WriteLine(str1);

string str3 = "Hello World";
string str4 = str3.Replace("World", "Universe");
Console.WriteLine(str3);

string str5 = "Hello";
string str6 = str5 + " World";
Console.WriteLine(str5);
```

### วิเคราะห์ว่าเพราะเหตุใด `String` จึงเป็น Immutable Class

1. **ไม่สามารถเปลี่ยนแปลงหลังจากสร้างขึ้น**
   - ไม่มี Setter สำหรับ Properties
   - ไม่สามารถเปลี่ยนแปลงอักขระแต่ละตัวได้
   ```csharp
   string str = "Hello";
   // str[0] = 'J';  //  ข้อผิดพลาด: Property or indexer 'string.this[int]' cannot be assigned to
   ```

2. **วิธีการทั้งหมดคืนค่า String ใหม่**
   - วิธีการไม่เปลี่ยนแปลง String เดิม เพียงแค่สร้าง String ใหม่ให้เราเลือก
   ```csharp
   string original = "Hello";
   
   // ToUpper() คืนค่า String ใหม่ ไม่เปลี่ยน original
   string uppercase = original.ToUpper();  // uppercase = "HELLO"
   Console.WriteLine(original);             // ยังคงเป็น "Hello"
   
   // Replace() ก็เช่นกัน
   string replaced = original.Replace("H", "J");  // replaced = "Jello"
   Console.WriteLine(original);                    // ยังคงเป็น "Hello"
   ```

3. **Thread-Safe และปลอดภัยมากกว่า**
   - เนื่องจากไม่สามารถเปลี่ยนแปลง String ได้หลังจากสร้างขึ้น
   - หลาย Threads สามารถใช้ String เดียวกันได้พร้อมกันโดยปลอดภัย
   ```csharp
   string sharedString = "Configuration Data";
   
   // Thread 1, 2, 3... สามารถอ่าน sharedString พร้อมกันได้
   // โดยไม่ต้องกังวลเรื่องการเปลี่ยนแปลง
   string thread1Result = sharedString.ToUpper();
   string thread2Result = sharedString.Substring(0, 5);
   ```

4. **Performance Optimization**
   - .NET สามารถ Cache String Literals ได้
   - หลาย Reference อาจชี้ไปยัง String Object เดียวกัน (String Interning)
   ```csharp
   string str1 = "Hello";
   string str2 = "Hello";
   
   // str1 และ str2 อาจชี้ไปยัง Object เดียวกันได้
   // เพราะว่า String ไม่สามารถเปลี่ยนแปลง
   ```

5. **Sealed Class ที่ไม่สามารถ Override ได้**
   - ใช้คำว่า `sealed` เพื่อป้องกันการสืบทอดและการเปลี่ยนแปลงพฤติกรรม

---


## บทสรุป

1. **Utility Class** (`Math`)
   - ออกแบบเพื่อให้บริการเป็นเครื่องมือ
   - ไม่มี Instance State
   - ใช้ Static Methods แต่ะเดียว

2. **Mutable Class** (`StringBuilder`)
   - ออกแบบให้สามารถเปลี่ยนแปลงข้อมูลได้
   - ประสิทธิภาพในการสร้าง String ขนาดใหญ่
   - Methods เปลี่ยนแปลง Object เดิม

3. **Immutable Class** (`String`)
   - ออกแบบให้ไม่สามารถเปลี่ยนแปลงได้
   - ปลอดภัยต่อการใช้ Multi-Threading
   - วิธีการสร้าง Object ใหม่เสมอ

การเข้าใจความแตกต่างระหว่างคลาสทั้งสามประเภทนี้จะช่วยให้ทำการออกแบบ Class โดยมีจุดประสงค์ที่ชัดเจนและเหมาะสมสำหรับแต่ละสถานการณ์


